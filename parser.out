Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    QUOTE
    TYPE

Grammar

Rule 0     S' -> expression
Rule 1     expression -> header rest
Rule 2     header -> HASH INCLUDE HEADER_FILE
Rule 3     rest -> VOID MAIN SMALL_OPEN SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
Rule 4     stmt -> for_stmt stmt
Rule 5     stmt -> switch_stmt stmt
Rule 6     stmt -> other_stmt stmt
Rule 7     stmt -> empty
Rule 8     other_stmt -> print_stmt other_stmt
Rule 9     other_stmt -> arithmetic_stmt other_stmt
Rule 10    other_stmt -> empty
Rule 11    switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
Rule 12    switch_body -> case_block switch_body
Rule 13    switch_body -> default_block
Rule 14    case_block -> CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE
Rule 15    default_block -> DEFAULT COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE
Rule 16    print_stmt -> PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON
Rule 17    arithmetic_stmt -> NUM_LITERAL BINARY_OP rest_arithmetic
Rule 18    rest_arithmetic -> arithmetic_stmt
Rule 19    rest_arithmetic -> NUM_LITERAL
Rule 20    for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
Rule 21    init_exp -> type IDENTIFIER empty
Rule 22    init_exp -> type IDENTIFIER ASSIGNMENT_OP NUM_LITERAL
Rule 23    init_exp -> empty
Rule 24    conditional_exp -> IDENTIFIER RELATIONAL_OP NUM_LITERAL
Rule 25    conditional_exp -> IDENTIFIER RELATIONAL_OP IDENTIFIER
Rule 26    conditional_exp -> empty
Rule 27    update_exp -> IDENTIFIER UNARY_OP
Rule 28    update_exp -> empty
Rule 29    type -> INT
Rule 30    type -> FLOAT
Rule 31    type -> CHAR
Rule 32    type -> DOUBLE
Rule 33    empty -> <empty>

Terminals, with rules where they appear

ASSIGNMENT_OP        : 22
BINARY_OP            : 17
BREAK                : 14 15
CASE                 : 14
CHAR                 : 31
COLON                : 14 15
DEFAULT              : 15
DOUBLE               : 32
FLOAT                : 30
FLOW_CLOSE           : 3 11 14 15 20
FLOW_OPEN            : 3 11 14 15 20
FOR                  : 20
HASH                 : 2
HEADER_FILE          : 2
IDENTIFIER           : 11 21 22 24 25 25 27
INCLUDE              : 2
INT                  : 29
MAIN                 : 3
NUM_LITERAL          : 14 17 19 22 24
PRINT                : 16
QUOTE                : 
RELATIONAL_OP        : 24 25
SEMI_COLON           : 14 15 16 20 20
SMALL_CLOSE          : 3 11 16 20
SMALL_OPEN           : 3 11 16 20
STRING_LITERAL       : 16
SWITCH               : 11
TYPE                 : 
UNARY_OP             : 27
VOID                 : 3
error                : 

Nonterminals, with rules where they appear

arithmetic_stmt      : 9 18
case_block           : 12
conditional_exp      : 20
default_block        : 13
empty                : 7 10 21 23 26 28
expression           : 0
for_stmt             : 4
header               : 1
init_exp             : 20
other_stmt           : 6 8 9
print_stmt           : 8
rest                 : 1
rest_arithmetic      : 17
stmt                 : 3 4 5 6 14 15 20
switch_body          : 11 12
switch_stmt          : 5
type                 : 21 22
update_exp           : 20

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . header rest
    (2) header -> . HASH INCLUDE HEADER_FILE

    HASH            shift and go to state 3

    expression                     shift and go to state 1
    header                         shift and go to state 2

state 1

    (0) S' -> expression .



state 2

    (1) expression -> header . rest
    (3) rest -> . VOID MAIN SMALL_OPEN SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    VOID            shift and go to state 5

    rest                           shift and go to state 4

state 3

    (2) header -> HASH . INCLUDE HEADER_FILE

    INCLUDE         shift and go to state 6


state 4

    (1) expression -> header rest .

    $end            reduce using rule 1 (expression -> header rest .)


state 5

    (3) rest -> VOID . MAIN SMALL_OPEN SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    MAIN            shift and go to state 7


state 6

    (2) header -> HASH INCLUDE . HEADER_FILE

    HEADER_FILE     shift and go to state 8


state 7

    (3) rest -> VOID MAIN . SMALL_OPEN SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    SMALL_OPEN      shift and go to state 9


state 8

    (2) header -> HASH INCLUDE HEADER_FILE .

    VOID            reduce using rule 2 (header -> HASH INCLUDE HEADER_FILE .)


state 9

    (3) rest -> VOID MAIN SMALL_OPEN . SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    SMALL_CLOSE     shift and go to state 10


state 10

    (3) rest -> VOID MAIN SMALL_OPEN SMALL_CLOSE . FLOW_OPEN stmt FLOW_CLOSE

    FLOW_OPEN       shift and go to state 11


state 11

    (3) rest -> VOID MAIN SMALL_OPEN SMALL_CLOSE FLOW_OPEN . stmt FLOW_CLOSE
    (4) stmt -> . for_stmt stmt
    (5) stmt -> . switch_stmt stmt
    (6) stmt -> . other_stmt stmt
    (7) stmt -> . empty
    (20) for_stmt -> . FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (11) switch_stmt -> . SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . arithmetic_stmt other_stmt
    (10) other_stmt -> . empty
    (33) empty -> .
    (16) print_stmt -> . PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON
    (17) arithmetic_stmt -> . NUM_LITERAL BINARY_OP rest_arithmetic

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for NUM_LITERAL resolved as shift
    FOR             shift and go to state 17
    SWITCH          shift and go to state 18
    FLOW_CLOSE      reduce using rule 33 (empty -> .)
    PRINT           shift and go to state 21
    NUM_LITERAL     shift and go to state 22

  ! FOR             [ reduce using rule 33 (empty -> .) ]
  ! SWITCH          [ reduce using rule 33 (empty -> .) ]
  ! PRINT           [ reduce using rule 33 (empty -> .) ]
  ! NUM_LITERAL     [ reduce using rule 33 (empty -> .) ]

    stmt                           shift and go to state 12
    for_stmt                       shift and go to state 13
    switch_stmt                    shift and go to state 14
    other_stmt                     shift and go to state 15
    empty                          shift and go to state 16
    print_stmt                     shift and go to state 19
    arithmetic_stmt                shift and go to state 20

state 12

    (3) rest -> VOID MAIN SMALL_OPEN SMALL_CLOSE FLOW_OPEN stmt . FLOW_CLOSE

    FLOW_CLOSE      shift and go to state 23


state 13

    (4) stmt -> for_stmt . stmt
    (4) stmt -> . for_stmt stmt
    (5) stmt -> . switch_stmt stmt
    (6) stmt -> . other_stmt stmt
    (7) stmt -> . empty
    (20) for_stmt -> . FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (11) switch_stmt -> . SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . arithmetic_stmt other_stmt
    (10) other_stmt -> . empty
    (33) empty -> .
    (16) print_stmt -> . PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON
    (17) arithmetic_stmt -> . NUM_LITERAL BINARY_OP rest_arithmetic

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for NUM_LITERAL resolved as shift
    FOR             shift and go to state 17
    SWITCH          shift and go to state 18
    FLOW_CLOSE      reduce using rule 33 (empty -> .)
    BREAK           reduce using rule 33 (empty -> .)
    PRINT           shift and go to state 21
    NUM_LITERAL     shift and go to state 22

  ! FOR             [ reduce using rule 33 (empty -> .) ]
  ! SWITCH          [ reduce using rule 33 (empty -> .) ]
  ! PRINT           [ reduce using rule 33 (empty -> .) ]
  ! NUM_LITERAL     [ reduce using rule 33 (empty -> .) ]

    for_stmt                       shift and go to state 13
    stmt                           shift and go to state 24
    switch_stmt                    shift and go to state 14
    other_stmt                     shift and go to state 15
    empty                          shift and go to state 16
    print_stmt                     shift and go to state 19
    arithmetic_stmt                shift and go to state 20

state 14

    (5) stmt -> switch_stmt . stmt
    (4) stmt -> . for_stmt stmt
    (5) stmt -> . switch_stmt stmt
    (6) stmt -> . other_stmt stmt
    (7) stmt -> . empty
    (20) for_stmt -> . FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (11) switch_stmt -> . SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . arithmetic_stmt other_stmt
    (10) other_stmt -> . empty
    (33) empty -> .
    (16) print_stmt -> . PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON
    (17) arithmetic_stmt -> . NUM_LITERAL BINARY_OP rest_arithmetic

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for NUM_LITERAL resolved as shift
    FOR             shift and go to state 17
    SWITCH          shift and go to state 18
    FLOW_CLOSE      reduce using rule 33 (empty -> .)
    BREAK           reduce using rule 33 (empty -> .)
    PRINT           shift and go to state 21
    NUM_LITERAL     shift and go to state 22

  ! FOR             [ reduce using rule 33 (empty -> .) ]
  ! SWITCH          [ reduce using rule 33 (empty -> .) ]
  ! PRINT           [ reduce using rule 33 (empty -> .) ]
  ! NUM_LITERAL     [ reduce using rule 33 (empty -> .) ]

    switch_stmt                    shift and go to state 14
    stmt                           shift and go to state 25
    for_stmt                       shift and go to state 13
    other_stmt                     shift and go to state 15
    empty                          shift and go to state 16
    print_stmt                     shift and go to state 19
    arithmetic_stmt                shift and go to state 20

state 15

    (6) stmt -> other_stmt . stmt
    (4) stmt -> . for_stmt stmt
    (5) stmt -> . switch_stmt stmt
    (6) stmt -> . other_stmt stmt
    (7) stmt -> . empty
    (20) for_stmt -> . FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (11) switch_stmt -> . SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . arithmetic_stmt other_stmt
    (10) other_stmt -> . empty
    (33) empty -> .
    (16) print_stmt -> . PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON
    (17) arithmetic_stmt -> . NUM_LITERAL BINARY_OP rest_arithmetic

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for NUM_LITERAL resolved as shift
    FOR             shift and go to state 17
    SWITCH          shift and go to state 18
    FLOW_CLOSE      reduce using rule 33 (empty -> .)
    BREAK           reduce using rule 33 (empty -> .)
    PRINT           shift and go to state 21
    NUM_LITERAL     shift and go to state 22

  ! FOR             [ reduce using rule 33 (empty -> .) ]
  ! SWITCH          [ reduce using rule 33 (empty -> .) ]
  ! PRINT           [ reduce using rule 33 (empty -> .) ]
  ! NUM_LITERAL     [ reduce using rule 33 (empty -> .) ]

    other_stmt                     shift and go to state 15
    stmt                           shift and go to state 26
    for_stmt                       shift and go to state 13
    switch_stmt                    shift and go to state 14
    empty                          shift and go to state 16
    print_stmt                     shift and go to state 19
    arithmetic_stmt                shift and go to state 20

state 16

    (7) stmt -> empty .
    (10) other_stmt -> empty .

  ! reduce/reduce conflict for FLOW_CLOSE resolved using rule 7 (stmt -> empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 7 (stmt -> empty .)
    FLOW_CLOSE      reduce using rule 7 (stmt -> empty .)
    BREAK           reduce using rule 7 (stmt -> empty .)
    FOR             reduce using rule 10 (other_stmt -> empty .)
    SWITCH          reduce using rule 10 (other_stmt -> empty .)
    PRINT           reduce using rule 10 (other_stmt -> empty .)
    NUM_LITERAL     reduce using rule 10 (other_stmt -> empty .)

  ! FLOW_CLOSE      [ reduce using rule 10 (other_stmt -> empty .) ]
  ! BREAK           [ reduce using rule 10 (other_stmt -> empty .) ]


state 17

    (20) for_stmt -> FOR . SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    SMALL_OPEN      shift and go to state 27


state 18

    (11) switch_stmt -> SWITCH . SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE

    SMALL_OPEN      shift and go to state 28


state 19

    (8) other_stmt -> print_stmt . other_stmt
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . arithmetic_stmt other_stmt
    (10) other_stmt -> . empty
    (16) print_stmt -> . PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON
    (17) arithmetic_stmt -> . NUM_LITERAL BINARY_OP rest_arithmetic
    (33) empty -> .

  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for NUM_LITERAL resolved as shift
    PRINT           shift and go to state 21
    NUM_LITERAL     shift and go to state 22
    FOR             reduce using rule 33 (empty -> .)
    SWITCH          reduce using rule 33 (empty -> .)
    FLOW_CLOSE      reduce using rule 33 (empty -> .)
    BREAK           reduce using rule 33 (empty -> .)

  ! PRINT           [ reduce using rule 33 (empty -> .) ]
  ! NUM_LITERAL     [ reduce using rule 33 (empty -> .) ]

    print_stmt                     shift and go to state 19
    other_stmt                     shift and go to state 29
    arithmetic_stmt                shift and go to state 20
    empty                          shift and go to state 30

state 20

    (9) other_stmt -> arithmetic_stmt . other_stmt
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . arithmetic_stmt other_stmt
    (10) other_stmt -> . empty
    (16) print_stmt -> . PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON
    (17) arithmetic_stmt -> . NUM_LITERAL BINARY_OP rest_arithmetic
    (33) empty -> .

  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for NUM_LITERAL resolved as shift
    PRINT           shift and go to state 21
    NUM_LITERAL     shift and go to state 22
    FOR             reduce using rule 33 (empty -> .)
    SWITCH          reduce using rule 33 (empty -> .)
    FLOW_CLOSE      reduce using rule 33 (empty -> .)
    BREAK           reduce using rule 33 (empty -> .)

  ! PRINT           [ reduce using rule 33 (empty -> .) ]
  ! NUM_LITERAL     [ reduce using rule 33 (empty -> .) ]

    arithmetic_stmt                shift and go to state 20
    other_stmt                     shift and go to state 31
    print_stmt                     shift and go to state 19
    empty                          shift and go to state 30

state 21

    (16) print_stmt -> PRINT . SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON

    SMALL_OPEN      shift and go to state 32


state 22

    (17) arithmetic_stmt -> NUM_LITERAL . BINARY_OP rest_arithmetic

    BINARY_OP       shift and go to state 33


state 23

    (3) rest -> VOID MAIN SMALL_OPEN SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .

    $end            reduce using rule 3 (rest -> VOID MAIN SMALL_OPEN SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .)


state 24

    (4) stmt -> for_stmt stmt .

    FLOW_CLOSE      reduce using rule 4 (stmt -> for_stmt stmt .)
    BREAK           reduce using rule 4 (stmt -> for_stmt stmt .)


state 25

    (5) stmt -> switch_stmt stmt .

    FLOW_CLOSE      reduce using rule 5 (stmt -> switch_stmt stmt .)
    BREAK           reduce using rule 5 (stmt -> switch_stmt stmt .)


state 26

    (6) stmt -> other_stmt stmt .

    FLOW_CLOSE      reduce using rule 6 (stmt -> other_stmt stmt .)
    BREAK           reduce using rule 6 (stmt -> other_stmt stmt .)


state 27

    (20) for_stmt -> FOR SMALL_OPEN . init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (21) init_exp -> . type IDENTIFIER empty
    (22) init_exp -> . type IDENTIFIER ASSIGNMENT_OP NUM_LITERAL
    (23) init_exp -> . empty
    (29) type -> . INT
    (30) type -> . FLOAT
    (31) type -> . CHAR
    (32) type -> . DOUBLE
    (33) empty -> .

    INT             shift and go to state 37
    FLOAT           shift and go to state 38
    CHAR            shift and go to state 39
    DOUBLE          shift and go to state 40
    SEMI_COLON      reduce using rule 33 (empty -> .)

    init_exp                       shift and go to state 34
    type                           shift and go to state 35
    empty                          shift and go to state 36

state 28

    (11) switch_stmt -> SWITCH SMALL_OPEN . IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE

    IDENTIFIER      shift and go to state 41


state 29

    (8) other_stmt -> print_stmt other_stmt .

    FOR             reduce using rule 8 (other_stmt -> print_stmt other_stmt .)
    SWITCH          reduce using rule 8 (other_stmt -> print_stmt other_stmt .)
    PRINT           reduce using rule 8 (other_stmt -> print_stmt other_stmt .)
    NUM_LITERAL     reduce using rule 8 (other_stmt -> print_stmt other_stmt .)
    FLOW_CLOSE      reduce using rule 8 (other_stmt -> print_stmt other_stmt .)
    BREAK           reduce using rule 8 (other_stmt -> print_stmt other_stmt .)


state 30

    (10) other_stmt -> empty .

    FOR             reduce using rule 10 (other_stmt -> empty .)
    SWITCH          reduce using rule 10 (other_stmt -> empty .)
    PRINT           reduce using rule 10 (other_stmt -> empty .)
    NUM_LITERAL     reduce using rule 10 (other_stmt -> empty .)
    FLOW_CLOSE      reduce using rule 10 (other_stmt -> empty .)
    BREAK           reduce using rule 10 (other_stmt -> empty .)


state 31

    (9) other_stmt -> arithmetic_stmt other_stmt .

    FOR             reduce using rule 9 (other_stmt -> arithmetic_stmt other_stmt .)
    SWITCH          reduce using rule 9 (other_stmt -> arithmetic_stmt other_stmt .)
    PRINT           reduce using rule 9 (other_stmt -> arithmetic_stmt other_stmt .)
    NUM_LITERAL     reduce using rule 9 (other_stmt -> arithmetic_stmt other_stmt .)
    FLOW_CLOSE      reduce using rule 9 (other_stmt -> arithmetic_stmt other_stmt .)
    BREAK           reduce using rule 9 (other_stmt -> arithmetic_stmt other_stmt .)


state 32

    (16) print_stmt -> PRINT SMALL_OPEN . STRING_LITERAL SMALL_CLOSE SEMI_COLON

    STRING_LITERAL  shift and go to state 42


state 33

    (17) arithmetic_stmt -> NUM_LITERAL BINARY_OP . rest_arithmetic
    (18) rest_arithmetic -> . arithmetic_stmt
    (19) rest_arithmetic -> . NUM_LITERAL
    (17) arithmetic_stmt -> . NUM_LITERAL BINARY_OP rest_arithmetic

    NUM_LITERAL     shift and go to state 43

    rest_arithmetic                shift and go to state 44
    arithmetic_stmt                shift and go to state 45

state 34

    (20) for_stmt -> FOR SMALL_OPEN init_exp . SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    SEMI_COLON      shift and go to state 46


state 35

    (21) init_exp -> type . IDENTIFIER empty
    (22) init_exp -> type . IDENTIFIER ASSIGNMENT_OP NUM_LITERAL

    IDENTIFIER      shift and go to state 47


state 36

    (23) init_exp -> empty .

    SEMI_COLON      reduce using rule 23 (init_exp -> empty .)


state 37

    (29) type -> INT .

    IDENTIFIER      reduce using rule 29 (type -> INT .)


state 38

    (30) type -> FLOAT .

    IDENTIFIER      reduce using rule 30 (type -> FLOAT .)


state 39

    (31) type -> CHAR .

    IDENTIFIER      reduce using rule 31 (type -> CHAR .)


state 40

    (32) type -> DOUBLE .

    IDENTIFIER      reduce using rule 32 (type -> DOUBLE .)


state 41

    (11) switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER . SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE

    SMALL_CLOSE     shift and go to state 48


state 42

    (16) print_stmt -> PRINT SMALL_OPEN STRING_LITERAL . SMALL_CLOSE SEMI_COLON

    SMALL_CLOSE     shift and go to state 49


state 43

    (19) rest_arithmetic -> NUM_LITERAL .
    (17) arithmetic_stmt -> NUM_LITERAL . BINARY_OP rest_arithmetic

    PRINT           reduce using rule 19 (rest_arithmetic -> NUM_LITERAL .)
    NUM_LITERAL     reduce using rule 19 (rest_arithmetic -> NUM_LITERAL .)
    FOR             reduce using rule 19 (rest_arithmetic -> NUM_LITERAL .)
    SWITCH          reduce using rule 19 (rest_arithmetic -> NUM_LITERAL .)
    FLOW_CLOSE      reduce using rule 19 (rest_arithmetic -> NUM_LITERAL .)
    BREAK           reduce using rule 19 (rest_arithmetic -> NUM_LITERAL .)
    BINARY_OP       shift and go to state 33


state 44

    (17) arithmetic_stmt -> NUM_LITERAL BINARY_OP rest_arithmetic .

    PRINT           reduce using rule 17 (arithmetic_stmt -> NUM_LITERAL BINARY_OP rest_arithmetic .)
    NUM_LITERAL     reduce using rule 17 (arithmetic_stmt -> NUM_LITERAL BINARY_OP rest_arithmetic .)
    FOR             reduce using rule 17 (arithmetic_stmt -> NUM_LITERAL BINARY_OP rest_arithmetic .)
    SWITCH          reduce using rule 17 (arithmetic_stmt -> NUM_LITERAL BINARY_OP rest_arithmetic .)
    FLOW_CLOSE      reduce using rule 17 (arithmetic_stmt -> NUM_LITERAL BINARY_OP rest_arithmetic .)
    BREAK           reduce using rule 17 (arithmetic_stmt -> NUM_LITERAL BINARY_OP rest_arithmetic .)


state 45

    (18) rest_arithmetic -> arithmetic_stmt .

    PRINT           reduce using rule 18 (rest_arithmetic -> arithmetic_stmt .)
    NUM_LITERAL     reduce using rule 18 (rest_arithmetic -> arithmetic_stmt .)
    FOR             reduce using rule 18 (rest_arithmetic -> arithmetic_stmt .)
    SWITCH          reduce using rule 18 (rest_arithmetic -> arithmetic_stmt .)
    FLOW_CLOSE      reduce using rule 18 (rest_arithmetic -> arithmetic_stmt .)
    BREAK           reduce using rule 18 (rest_arithmetic -> arithmetic_stmt .)


state 46

    (20) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON . conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (24) conditional_exp -> . IDENTIFIER RELATIONAL_OP NUM_LITERAL
    (25) conditional_exp -> . IDENTIFIER RELATIONAL_OP IDENTIFIER
    (26) conditional_exp -> . empty
    (33) empty -> .

    IDENTIFIER      shift and go to state 51
    SEMI_COLON      reduce using rule 33 (empty -> .)

    conditional_exp                shift and go to state 50
    empty                          shift and go to state 52

state 47

    (21) init_exp -> type IDENTIFIER . empty
    (22) init_exp -> type IDENTIFIER . ASSIGNMENT_OP NUM_LITERAL
    (33) empty -> .

    ASSIGNMENT_OP   shift and go to state 54
    SEMI_COLON      reduce using rule 33 (empty -> .)

    empty                          shift and go to state 53

state 48

    (11) switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE . FLOW_OPEN switch_body FLOW_CLOSE

    FLOW_OPEN       shift and go to state 55


state 49

    (16) print_stmt -> PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE . SEMI_COLON

    SEMI_COLON      shift and go to state 56


state 50

    (20) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp . SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    SEMI_COLON      shift and go to state 57


state 51

    (24) conditional_exp -> IDENTIFIER . RELATIONAL_OP NUM_LITERAL
    (25) conditional_exp -> IDENTIFIER . RELATIONAL_OP IDENTIFIER

    RELATIONAL_OP   shift and go to state 58


state 52

    (26) conditional_exp -> empty .

    SEMI_COLON      reduce using rule 26 (conditional_exp -> empty .)


state 53

    (21) init_exp -> type IDENTIFIER empty .

    SEMI_COLON      reduce using rule 21 (init_exp -> type IDENTIFIER empty .)


state 54

    (22) init_exp -> type IDENTIFIER ASSIGNMENT_OP . NUM_LITERAL

    NUM_LITERAL     shift and go to state 59


state 55

    (11) switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN . switch_body FLOW_CLOSE
    (12) switch_body -> . case_block switch_body
    (13) switch_body -> . default_block
    (14) case_block -> . CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE
    (15) default_block -> . DEFAULT COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE

    CASE            shift and go to state 63
    DEFAULT         shift and go to state 64

    switch_body                    shift and go to state 60
    case_block                     shift and go to state 61
    default_block                  shift and go to state 62

state 56

    (16) print_stmt -> PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON .

    PRINT           reduce using rule 16 (print_stmt -> PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON .)
    NUM_LITERAL     reduce using rule 16 (print_stmt -> PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON .)
    FOR             reduce using rule 16 (print_stmt -> PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON .)
    SWITCH          reduce using rule 16 (print_stmt -> PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON .)
    FLOW_CLOSE      reduce using rule 16 (print_stmt -> PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON .)
    BREAK           reduce using rule 16 (print_stmt -> PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON .)


state 57

    (20) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON . update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (27) update_exp -> . IDENTIFIER UNARY_OP
    (28) update_exp -> . empty
    (33) empty -> .

    IDENTIFIER      shift and go to state 66
    SMALL_CLOSE     reduce using rule 33 (empty -> .)

    update_exp                     shift and go to state 65
    empty                          shift and go to state 67

state 58

    (24) conditional_exp -> IDENTIFIER RELATIONAL_OP . NUM_LITERAL
    (25) conditional_exp -> IDENTIFIER RELATIONAL_OP . IDENTIFIER

    NUM_LITERAL     shift and go to state 69
    IDENTIFIER      shift and go to state 68


state 59

    (22) init_exp -> type IDENTIFIER ASSIGNMENT_OP NUM_LITERAL .

    SEMI_COLON      reduce using rule 22 (init_exp -> type IDENTIFIER ASSIGNMENT_OP NUM_LITERAL .)


state 60

    (11) switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body . FLOW_CLOSE

    FLOW_CLOSE      shift and go to state 70


state 61

    (12) switch_body -> case_block . switch_body
    (12) switch_body -> . case_block switch_body
    (13) switch_body -> . default_block
    (14) case_block -> . CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE
    (15) default_block -> . DEFAULT COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE

    CASE            shift and go to state 63
    DEFAULT         shift and go to state 64

    case_block                     shift and go to state 61
    switch_body                    shift and go to state 71
    default_block                  shift and go to state 62

state 62

    (13) switch_body -> default_block .

    FLOW_CLOSE      reduce using rule 13 (switch_body -> default_block .)


state 63

    (14) case_block -> CASE . NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE

    NUM_LITERAL     shift and go to state 72


state 64

    (15) default_block -> DEFAULT . COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE

    COLON           shift and go to state 73


state 65

    (20) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp . SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    SMALL_CLOSE     shift and go to state 74


state 66

    (27) update_exp -> IDENTIFIER . UNARY_OP

    UNARY_OP        shift and go to state 75


state 67

    (28) update_exp -> empty .

    SMALL_CLOSE     reduce using rule 28 (update_exp -> empty .)


state 68

    (25) conditional_exp -> IDENTIFIER RELATIONAL_OP IDENTIFIER .

    SEMI_COLON      reduce using rule 25 (conditional_exp -> IDENTIFIER RELATIONAL_OP IDENTIFIER .)


state 69

    (24) conditional_exp -> IDENTIFIER RELATIONAL_OP NUM_LITERAL .

    SEMI_COLON      reduce using rule 24 (conditional_exp -> IDENTIFIER RELATIONAL_OP NUM_LITERAL .)


state 70

    (11) switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE .

    FOR             reduce using rule 11 (switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE .)
    SWITCH          reduce using rule 11 (switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE .)
    PRINT           reduce using rule 11 (switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE .)
    NUM_LITERAL     reduce using rule 11 (switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE .)
    FLOW_CLOSE      reduce using rule 11 (switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE .)
    BREAK           reduce using rule 11 (switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE .)


state 71

    (12) switch_body -> case_block switch_body .

    FLOW_CLOSE      reduce using rule 12 (switch_body -> case_block switch_body .)


state 72

    (14) case_block -> CASE NUM_LITERAL . COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE

    COLON           shift and go to state 76


state 73

    (15) default_block -> DEFAULT COLON . FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE

    FLOW_OPEN       shift and go to state 77


state 74

    (20) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE . FLOW_OPEN stmt FLOW_CLOSE

    FLOW_OPEN       shift and go to state 78


state 75

    (27) update_exp -> IDENTIFIER UNARY_OP .

    SMALL_CLOSE     reduce using rule 27 (update_exp -> IDENTIFIER UNARY_OP .)


state 76

    (14) case_block -> CASE NUM_LITERAL COLON . FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE

    FLOW_OPEN       shift and go to state 79


state 77

    (15) default_block -> DEFAULT COLON FLOW_OPEN . stmt BREAK SEMI_COLON FLOW_CLOSE
    (4) stmt -> . for_stmt stmt
    (5) stmt -> . switch_stmt stmt
    (6) stmt -> . other_stmt stmt
    (7) stmt -> . empty
    (20) for_stmt -> . FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (11) switch_stmt -> . SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . arithmetic_stmt other_stmt
    (10) other_stmt -> . empty
    (33) empty -> .
    (16) print_stmt -> . PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON
    (17) arithmetic_stmt -> . NUM_LITERAL BINARY_OP rest_arithmetic

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for NUM_LITERAL resolved as shift
    FOR             shift and go to state 17
    SWITCH          shift and go to state 18
    BREAK           reduce using rule 33 (empty -> .)
    PRINT           shift and go to state 21
    NUM_LITERAL     shift and go to state 22

  ! FOR             [ reduce using rule 33 (empty -> .) ]
  ! SWITCH          [ reduce using rule 33 (empty -> .) ]
  ! PRINT           [ reduce using rule 33 (empty -> .) ]
  ! NUM_LITERAL     [ reduce using rule 33 (empty -> .) ]

    stmt                           shift and go to state 80
    for_stmt                       shift and go to state 13
    switch_stmt                    shift and go to state 14
    other_stmt                     shift and go to state 15
    empty                          shift and go to state 16
    print_stmt                     shift and go to state 19
    arithmetic_stmt                shift and go to state 20

state 78

    (20) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN . stmt FLOW_CLOSE
    (4) stmt -> . for_stmt stmt
    (5) stmt -> . switch_stmt stmt
    (6) stmt -> . other_stmt stmt
    (7) stmt -> . empty
    (20) for_stmt -> . FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (11) switch_stmt -> . SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . arithmetic_stmt other_stmt
    (10) other_stmt -> . empty
    (33) empty -> .
    (16) print_stmt -> . PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON
    (17) arithmetic_stmt -> . NUM_LITERAL BINARY_OP rest_arithmetic

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for NUM_LITERAL resolved as shift
    FOR             shift and go to state 17
    SWITCH          shift and go to state 18
    FLOW_CLOSE      reduce using rule 33 (empty -> .)
    PRINT           shift and go to state 21
    NUM_LITERAL     shift and go to state 22

  ! FOR             [ reduce using rule 33 (empty -> .) ]
  ! SWITCH          [ reduce using rule 33 (empty -> .) ]
  ! PRINT           [ reduce using rule 33 (empty -> .) ]
  ! NUM_LITERAL     [ reduce using rule 33 (empty -> .) ]

    stmt                           shift and go to state 81
    for_stmt                       shift and go to state 13
    switch_stmt                    shift and go to state 14
    other_stmt                     shift and go to state 15
    empty                          shift and go to state 16
    print_stmt                     shift and go to state 19
    arithmetic_stmt                shift and go to state 20

state 79

    (14) case_block -> CASE NUM_LITERAL COLON FLOW_OPEN . stmt BREAK SEMI_COLON FLOW_CLOSE
    (4) stmt -> . for_stmt stmt
    (5) stmt -> . switch_stmt stmt
    (6) stmt -> . other_stmt stmt
    (7) stmt -> . empty
    (20) for_stmt -> . FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (11) switch_stmt -> . SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . arithmetic_stmt other_stmt
    (10) other_stmt -> . empty
    (33) empty -> .
    (16) print_stmt -> . PRINT SMALL_OPEN STRING_LITERAL SMALL_CLOSE SEMI_COLON
    (17) arithmetic_stmt -> . NUM_LITERAL BINARY_OP rest_arithmetic

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for NUM_LITERAL resolved as shift
    FOR             shift and go to state 17
    SWITCH          shift and go to state 18
    BREAK           reduce using rule 33 (empty -> .)
    PRINT           shift and go to state 21
    NUM_LITERAL     shift and go to state 22

  ! FOR             [ reduce using rule 33 (empty -> .) ]
  ! SWITCH          [ reduce using rule 33 (empty -> .) ]
  ! PRINT           [ reduce using rule 33 (empty -> .) ]
  ! NUM_LITERAL     [ reduce using rule 33 (empty -> .) ]

    stmt                           shift and go to state 82
    for_stmt                       shift and go to state 13
    switch_stmt                    shift and go to state 14
    other_stmt                     shift and go to state 15
    empty                          shift and go to state 16
    print_stmt                     shift and go to state 19
    arithmetic_stmt                shift and go to state 20

state 80

    (15) default_block -> DEFAULT COLON FLOW_OPEN stmt . BREAK SEMI_COLON FLOW_CLOSE

    BREAK           shift and go to state 83


state 81

    (20) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt . FLOW_CLOSE

    FLOW_CLOSE      shift and go to state 84


state 82

    (14) case_block -> CASE NUM_LITERAL COLON FLOW_OPEN stmt . BREAK SEMI_COLON FLOW_CLOSE

    BREAK           shift and go to state 85


state 83

    (15) default_block -> DEFAULT COLON FLOW_OPEN stmt BREAK . SEMI_COLON FLOW_CLOSE

    SEMI_COLON      shift and go to state 86


state 84

    (20) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .

    FOR             reduce using rule 20 (for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .)
    SWITCH          reduce using rule 20 (for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .)
    PRINT           reduce using rule 20 (for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .)
    NUM_LITERAL     reduce using rule 20 (for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .)
    FLOW_CLOSE      reduce using rule 20 (for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .)
    BREAK           reduce using rule 20 (for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .)


state 85

    (14) case_block -> CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK . SEMI_COLON FLOW_CLOSE

    SEMI_COLON      shift and go to state 87


state 86

    (15) default_block -> DEFAULT COLON FLOW_OPEN stmt BREAK SEMI_COLON . FLOW_CLOSE

    FLOW_CLOSE      shift and go to state 88


state 87

    (14) case_block -> CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON . FLOW_CLOSE

    FLOW_CLOSE      shift and go to state 89


state 88

    (15) default_block -> DEFAULT COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE .

    FLOW_CLOSE      reduce using rule 15 (default_block -> DEFAULT COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE .)


state 89

    (14) case_block -> CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE .

    CASE            reduce using rule 14 (case_block -> CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE .)
    DEFAULT         reduce using rule 14 (case_block -> CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FOR in state 11 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 11 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 11 resolved as shift
WARNING: shift/reduce conflict for NUM_LITERAL in state 11 resolved as shift
WARNING: shift/reduce conflict for FOR in state 13 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 13 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 13 resolved as shift
WARNING: shift/reduce conflict for NUM_LITERAL in state 13 resolved as shift
WARNING: shift/reduce conflict for FOR in state 14 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 14 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 14 resolved as shift
WARNING: shift/reduce conflict for NUM_LITERAL in state 14 resolved as shift
WARNING: shift/reduce conflict for FOR in state 15 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 15 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 15 resolved as shift
WARNING: shift/reduce conflict for NUM_LITERAL in state 15 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 19 resolved as shift
WARNING: shift/reduce conflict for NUM_LITERAL in state 19 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 20 resolved as shift
WARNING: shift/reduce conflict for NUM_LITERAL in state 20 resolved as shift
WARNING: shift/reduce conflict for FOR in state 77 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 77 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 77 resolved as shift
WARNING: shift/reduce conflict for NUM_LITERAL in state 77 resolved as shift
WARNING: shift/reduce conflict for FOR in state 78 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 78 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 78 resolved as shift
WARNING: shift/reduce conflict for NUM_LITERAL in state 78 resolved as shift
WARNING: shift/reduce conflict for FOR in state 79 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 79 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 79 resolved as shift
WARNING: shift/reduce conflict for NUM_LITERAL in state 79 resolved as shift
WARNING: reduce/reduce conflict in state 16 resolved using rule (stmt -> empty)
WARNING: rejected rule (other_stmt -> empty) in state 16
