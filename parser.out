Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BINARY_OP
    TYPE

Grammar

Rule 0     S' -> expression
Rule 1     expression -> header rest
Rule 2     header -> HASH INCLUDE HEADER_FILE
Rule 3     rest -> VOID MAIN SMALL_OPEN SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
Rule 4     stmt -> for_stmt stmt
Rule 5     stmt -> switch_stmt stmt
Rule 6     stmt -> other_stmt stmt
Rule 7     stmt -> empty
Rule 8     other_stmt -> print_stmt other_stmt
Rule 9     other_stmt -> empty
Rule 10    switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
Rule 11    switch_body -> case_block switch_body
Rule 12    switch_body -> default_block
Rule 13    case_block -> CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE
Rule 14    default_block -> DEFAULT COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE
Rule 15    print_stmt -> PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON
Rule 16    for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
Rule 17    init_exp -> type IDENTIFIER empty
Rule 18    init_exp -> type IDENTIFIER ASSIGNMENT_OP NUM_LITERAL
Rule 19    init_exp -> empty
Rule 20    conditional_exp -> IDENTIFIER RELATIONAL_OP NUM_LITERAL
Rule 21    conditional_exp -> IDENTIFIER RELATIONAL_OP IDENTIFIER
Rule 22    conditional_exp -> empty
Rule 23    update_exp -> IDENTIFIER UNARY_OP
Rule 24    update_exp -> empty
Rule 25    type -> INT
Rule 26    type -> FLOAT
Rule 27    type -> CHAR
Rule 28    type -> DOUBLE
Rule 29    empty -> <empty>

Terminals, with rules where they appear

ASSIGNMENT_OP        : 18
BINARY_OP            : 
BREAK                : 13 14
CASE                 : 13
CHAR                 : 27
COLON                : 13 14
DEFAULT              : 14
DOUBLE               : 28
FLOAT                : 26
FLOW_CLOSE           : 3 10 13 14 16
FLOW_OPEN            : 3 10 13 14 16
FOR                  : 16
HASH                 : 2
HEADER_FILE          : 2
IDENTIFIER           : 10 15 17 18 20 21 21 23
INCLUDE              : 2
INT                  : 25
MAIN                 : 3
NUM_LITERAL          : 13 18 20
PRINT                : 15
QUOTE                : 15 15
RELATIONAL_OP        : 20 21
SEMI_COLON           : 13 14 15 16 16
SMALL_CLOSE          : 3 10 15 16
SMALL_OPEN           : 3 10 15 16
SWITCH               : 10
TYPE                 : 
UNARY_OP             : 23
VOID                 : 3
error                : 

Nonterminals, with rules where they appear

case_block           : 11
conditional_exp      : 16
default_block        : 12
empty                : 7 9 17 19 22 24
expression           : 0
for_stmt             : 4
header               : 1
init_exp             : 16
other_stmt           : 6 8
print_stmt           : 8
rest                 : 1
stmt                 : 3 4 5 6 13 14 16
switch_body          : 10 11
switch_stmt          : 5
type                 : 17 18
update_exp           : 16

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . header rest
    (2) header -> . HASH INCLUDE HEADER_FILE

    HASH            shift and go to state 3

    expression                     shift and go to state 1
    header                         shift and go to state 2

state 1

    (0) S' -> expression .



state 2

    (1) expression -> header . rest
    (3) rest -> . VOID MAIN SMALL_OPEN SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    VOID            shift and go to state 5

    rest                           shift and go to state 4

state 3

    (2) header -> HASH . INCLUDE HEADER_FILE

    INCLUDE         shift and go to state 6


state 4

    (1) expression -> header rest .

    $end            reduce using rule 1 (expression -> header rest .)


state 5

    (3) rest -> VOID . MAIN SMALL_OPEN SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    MAIN            shift and go to state 7


state 6

    (2) header -> HASH INCLUDE . HEADER_FILE

    HEADER_FILE     shift and go to state 8


state 7

    (3) rest -> VOID MAIN . SMALL_OPEN SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    SMALL_OPEN      shift and go to state 9


state 8

    (2) header -> HASH INCLUDE HEADER_FILE .

    VOID            reduce using rule 2 (header -> HASH INCLUDE HEADER_FILE .)


state 9

    (3) rest -> VOID MAIN SMALL_OPEN . SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    SMALL_CLOSE     shift and go to state 10


state 10

    (3) rest -> VOID MAIN SMALL_OPEN SMALL_CLOSE . FLOW_OPEN stmt FLOW_CLOSE

    FLOW_OPEN       shift and go to state 11


state 11

    (3) rest -> VOID MAIN SMALL_OPEN SMALL_CLOSE FLOW_OPEN . stmt FLOW_CLOSE
    (4) stmt -> . for_stmt stmt
    (5) stmt -> . switch_stmt stmt
    (6) stmt -> . other_stmt stmt
    (7) stmt -> . empty
    (16) for_stmt -> . FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (10) switch_stmt -> . SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . empty
    (29) empty -> .
    (15) print_stmt -> . PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    FOR             shift and go to state 17
    SWITCH          shift and go to state 18
    FLOW_CLOSE      reduce using rule 29 (empty -> .)
    PRINT           shift and go to state 20

  ! FOR             [ reduce using rule 29 (empty -> .) ]
  ! SWITCH          [ reduce using rule 29 (empty -> .) ]
  ! PRINT           [ reduce using rule 29 (empty -> .) ]

    stmt                           shift and go to state 12
    for_stmt                       shift and go to state 13
    switch_stmt                    shift and go to state 14
    other_stmt                     shift and go to state 15
    empty                          shift and go to state 16
    print_stmt                     shift and go to state 19

state 12

    (3) rest -> VOID MAIN SMALL_OPEN SMALL_CLOSE FLOW_OPEN stmt . FLOW_CLOSE

    FLOW_CLOSE      shift and go to state 21


state 13

    (4) stmt -> for_stmt . stmt
    (4) stmt -> . for_stmt stmt
    (5) stmt -> . switch_stmt stmt
    (6) stmt -> . other_stmt stmt
    (7) stmt -> . empty
    (16) for_stmt -> . FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (10) switch_stmt -> . SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . empty
    (29) empty -> .
    (15) print_stmt -> . PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    FOR             shift and go to state 17
    SWITCH          shift and go to state 18
    FLOW_CLOSE      reduce using rule 29 (empty -> .)
    BREAK           reduce using rule 29 (empty -> .)
    PRINT           shift and go to state 20

  ! FOR             [ reduce using rule 29 (empty -> .) ]
  ! SWITCH          [ reduce using rule 29 (empty -> .) ]
  ! PRINT           [ reduce using rule 29 (empty -> .) ]

    for_stmt                       shift and go to state 13
    stmt                           shift and go to state 22
    switch_stmt                    shift and go to state 14
    other_stmt                     shift and go to state 15
    empty                          shift and go to state 16
    print_stmt                     shift and go to state 19

state 14

    (5) stmt -> switch_stmt . stmt
    (4) stmt -> . for_stmt stmt
    (5) stmt -> . switch_stmt stmt
    (6) stmt -> . other_stmt stmt
    (7) stmt -> . empty
    (16) for_stmt -> . FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (10) switch_stmt -> . SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . empty
    (29) empty -> .
    (15) print_stmt -> . PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    FOR             shift and go to state 17
    SWITCH          shift and go to state 18
    FLOW_CLOSE      reduce using rule 29 (empty -> .)
    BREAK           reduce using rule 29 (empty -> .)
    PRINT           shift and go to state 20

  ! FOR             [ reduce using rule 29 (empty -> .) ]
  ! SWITCH          [ reduce using rule 29 (empty -> .) ]
  ! PRINT           [ reduce using rule 29 (empty -> .) ]

    switch_stmt                    shift and go to state 14
    stmt                           shift and go to state 23
    for_stmt                       shift and go to state 13
    other_stmt                     shift and go to state 15
    empty                          shift and go to state 16
    print_stmt                     shift and go to state 19

state 15

    (6) stmt -> other_stmt . stmt
    (4) stmt -> . for_stmt stmt
    (5) stmt -> . switch_stmt stmt
    (6) stmt -> . other_stmt stmt
    (7) stmt -> . empty
    (16) for_stmt -> . FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (10) switch_stmt -> . SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . empty
    (29) empty -> .
    (15) print_stmt -> . PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    FOR             shift and go to state 17
    SWITCH          shift and go to state 18
    FLOW_CLOSE      reduce using rule 29 (empty -> .)
    BREAK           reduce using rule 29 (empty -> .)
    PRINT           shift and go to state 20

  ! FOR             [ reduce using rule 29 (empty -> .) ]
  ! SWITCH          [ reduce using rule 29 (empty -> .) ]
  ! PRINT           [ reduce using rule 29 (empty -> .) ]

    other_stmt                     shift and go to state 15
    stmt                           shift and go to state 24
    for_stmt                       shift and go to state 13
    switch_stmt                    shift and go to state 14
    empty                          shift and go to state 16
    print_stmt                     shift and go to state 19

state 16

    (7) stmt -> empty .
    (9) other_stmt -> empty .

  ! reduce/reduce conflict for FLOW_CLOSE resolved using rule 7 (stmt -> empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 7 (stmt -> empty .)
    FLOW_CLOSE      reduce using rule 7 (stmt -> empty .)
    BREAK           reduce using rule 7 (stmt -> empty .)
    FOR             reduce using rule 9 (other_stmt -> empty .)
    SWITCH          reduce using rule 9 (other_stmt -> empty .)
    PRINT           reduce using rule 9 (other_stmt -> empty .)

  ! FLOW_CLOSE      [ reduce using rule 9 (other_stmt -> empty .) ]
  ! BREAK           [ reduce using rule 9 (other_stmt -> empty .) ]


state 17

    (16) for_stmt -> FOR . SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    SMALL_OPEN      shift and go to state 25


state 18

    (10) switch_stmt -> SWITCH . SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE

    SMALL_OPEN      shift and go to state 26


state 19

    (8) other_stmt -> print_stmt . other_stmt
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . empty
    (15) print_stmt -> . PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON
    (29) empty -> .

  ! shift/reduce conflict for PRINT resolved as shift
    PRINT           shift and go to state 20
    FOR             reduce using rule 29 (empty -> .)
    SWITCH          reduce using rule 29 (empty -> .)
    FLOW_CLOSE      reduce using rule 29 (empty -> .)
    BREAK           reduce using rule 29 (empty -> .)

  ! PRINT           [ reduce using rule 29 (empty -> .) ]

    print_stmt                     shift and go to state 19
    other_stmt                     shift and go to state 27
    empty                          shift and go to state 28

state 20

    (15) print_stmt -> PRINT . SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON

    SMALL_OPEN      shift and go to state 29


state 21

    (3) rest -> VOID MAIN SMALL_OPEN SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .

    $end            reduce using rule 3 (rest -> VOID MAIN SMALL_OPEN SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .)


state 22

    (4) stmt -> for_stmt stmt .

    FLOW_CLOSE      reduce using rule 4 (stmt -> for_stmt stmt .)
    BREAK           reduce using rule 4 (stmt -> for_stmt stmt .)


state 23

    (5) stmt -> switch_stmt stmt .

    FLOW_CLOSE      reduce using rule 5 (stmt -> switch_stmt stmt .)
    BREAK           reduce using rule 5 (stmt -> switch_stmt stmt .)


state 24

    (6) stmt -> other_stmt stmt .

    FLOW_CLOSE      reduce using rule 6 (stmt -> other_stmt stmt .)
    BREAK           reduce using rule 6 (stmt -> other_stmt stmt .)


state 25

    (16) for_stmt -> FOR SMALL_OPEN . init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (17) init_exp -> . type IDENTIFIER empty
    (18) init_exp -> . type IDENTIFIER ASSIGNMENT_OP NUM_LITERAL
    (19) init_exp -> . empty
    (25) type -> . INT
    (26) type -> . FLOAT
    (27) type -> . CHAR
    (28) type -> . DOUBLE
    (29) empty -> .

    INT             shift and go to state 33
    FLOAT           shift and go to state 34
    CHAR            shift and go to state 35
    DOUBLE          shift and go to state 36
    SEMI_COLON      reduce using rule 29 (empty -> .)

    init_exp                       shift and go to state 30
    type                           shift and go to state 31
    empty                          shift and go to state 32

state 26

    (10) switch_stmt -> SWITCH SMALL_OPEN . IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE

    IDENTIFIER      shift and go to state 37


state 27

    (8) other_stmt -> print_stmt other_stmt .

    FOR             reduce using rule 8 (other_stmt -> print_stmt other_stmt .)
    SWITCH          reduce using rule 8 (other_stmt -> print_stmt other_stmt .)
    PRINT           reduce using rule 8 (other_stmt -> print_stmt other_stmt .)
    FLOW_CLOSE      reduce using rule 8 (other_stmt -> print_stmt other_stmt .)
    BREAK           reduce using rule 8 (other_stmt -> print_stmt other_stmt .)


state 28

    (9) other_stmt -> empty .

    FOR             reduce using rule 9 (other_stmt -> empty .)
    SWITCH          reduce using rule 9 (other_stmt -> empty .)
    PRINT           reduce using rule 9 (other_stmt -> empty .)
    FLOW_CLOSE      reduce using rule 9 (other_stmt -> empty .)
    BREAK           reduce using rule 9 (other_stmt -> empty .)


state 29

    (15) print_stmt -> PRINT SMALL_OPEN . QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON

    QUOTE           shift and go to state 38


state 30

    (16) for_stmt -> FOR SMALL_OPEN init_exp . SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    SEMI_COLON      shift and go to state 39


state 31

    (17) init_exp -> type . IDENTIFIER empty
    (18) init_exp -> type . IDENTIFIER ASSIGNMENT_OP NUM_LITERAL

    IDENTIFIER      shift and go to state 40


state 32

    (19) init_exp -> empty .

    SEMI_COLON      reduce using rule 19 (init_exp -> empty .)


state 33

    (25) type -> INT .

    IDENTIFIER      reduce using rule 25 (type -> INT .)


state 34

    (26) type -> FLOAT .

    IDENTIFIER      reduce using rule 26 (type -> FLOAT .)


state 35

    (27) type -> CHAR .

    IDENTIFIER      reduce using rule 27 (type -> CHAR .)


state 36

    (28) type -> DOUBLE .

    IDENTIFIER      reduce using rule 28 (type -> DOUBLE .)


state 37

    (10) switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER . SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE

    SMALL_CLOSE     shift and go to state 41


state 38

    (15) print_stmt -> PRINT SMALL_OPEN QUOTE . IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON

    IDENTIFIER      shift and go to state 42


state 39

    (16) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON . conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (20) conditional_exp -> . IDENTIFIER RELATIONAL_OP NUM_LITERAL
    (21) conditional_exp -> . IDENTIFIER RELATIONAL_OP IDENTIFIER
    (22) conditional_exp -> . empty
    (29) empty -> .

    IDENTIFIER      shift and go to state 44
    SEMI_COLON      reduce using rule 29 (empty -> .)

    conditional_exp                shift and go to state 43
    empty                          shift and go to state 45

state 40

    (17) init_exp -> type IDENTIFIER . empty
    (18) init_exp -> type IDENTIFIER . ASSIGNMENT_OP NUM_LITERAL
    (29) empty -> .

    ASSIGNMENT_OP   shift and go to state 47
    SEMI_COLON      reduce using rule 29 (empty -> .)

    empty                          shift and go to state 46

state 41

    (10) switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE . FLOW_OPEN switch_body FLOW_CLOSE

    FLOW_OPEN       shift and go to state 48


state 42

    (15) print_stmt -> PRINT SMALL_OPEN QUOTE IDENTIFIER . QUOTE SMALL_CLOSE SEMI_COLON

    QUOTE           shift and go to state 49


state 43

    (16) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp . SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    SEMI_COLON      shift and go to state 50


state 44

    (20) conditional_exp -> IDENTIFIER . RELATIONAL_OP NUM_LITERAL
    (21) conditional_exp -> IDENTIFIER . RELATIONAL_OP IDENTIFIER

    RELATIONAL_OP   shift and go to state 51


state 45

    (22) conditional_exp -> empty .

    SEMI_COLON      reduce using rule 22 (conditional_exp -> empty .)


state 46

    (17) init_exp -> type IDENTIFIER empty .

    SEMI_COLON      reduce using rule 17 (init_exp -> type IDENTIFIER empty .)


state 47

    (18) init_exp -> type IDENTIFIER ASSIGNMENT_OP . NUM_LITERAL

    NUM_LITERAL     shift and go to state 52


state 48

    (10) switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN . switch_body FLOW_CLOSE
    (11) switch_body -> . case_block switch_body
    (12) switch_body -> . default_block
    (13) case_block -> . CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE
    (14) default_block -> . DEFAULT COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE

    CASE            shift and go to state 56
    DEFAULT         shift and go to state 57

    switch_body                    shift and go to state 53
    case_block                     shift and go to state 54
    default_block                  shift and go to state 55

state 49

    (15) print_stmt -> PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE . SMALL_CLOSE SEMI_COLON

    SMALL_CLOSE     shift and go to state 58


state 50

    (16) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON . update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (23) update_exp -> . IDENTIFIER UNARY_OP
    (24) update_exp -> . empty
    (29) empty -> .

    IDENTIFIER      shift and go to state 60
    SMALL_CLOSE     reduce using rule 29 (empty -> .)

    update_exp                     shift and go to state 59
    empty                          shift and go to state 61

state 51

    (20) conditional_exp -> IDENTIFIER RELATIONAL_OP . NUM_LITERAL
    (21) conditional_exp -> IDENTIFIER RELATIONAL_OP . IDENTIFIER

    NUM_LITERAL     shift and go to state 63
    IDENTIFIER      shift and go to state 62


state 52

    (18) init_exp -> type IDENTIFIER ASSIGNMENT_OP NUM_LITERAL .

    SEMI_COLON      reduce using rule 18 (init_exp -> type IDENTIFIER ASSIGNMENT_OP NUM_LITERAL .)


state 53

    (10) switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body . FLOW_CLOSE

    FLOW_CLOSE      shift and go to state 64


state 54

    (11) switch_body -> case_block . switch_body
    (11) switch_body -> . case_block switch_body
    (12) switch_body -> . default_block
    (13) case_block -> . CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE
    (14) default_block -> . DEFAULT COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE

    CASE            shift and go to state 56
    DEFAULT         shift and go to state 57

    case_block                     shift and go to state 54
    switch_body                    shift and go to state 65
    default_block                  shift and go to state 55

state 55

    (12) switch_body -> default_block .

    FLOW_CLOSE      reduce using rule 12 (switch_body -> default_block .)


state 56

    (13) case_block -> CASE . NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE

    NUM_LITERAL     shift and go to state 66


state 57

    (14) default_block -> DEFAULT . COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE

    COLON           shift and go to state 67


state 58

    (15) print_stmt -> PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE . SEMI_COLON

    SEMI_COLON      shift and go to state 68


state 59

    (16) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp . SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE

    SMALL_CLOSE     shift and go to state 69


state 60

    (23) update_exp -> IDENTIFIER . UNARY_OP

    UNARY_OP        shift and go to state 70


state 61

    (24) update_exp -> empty .

    SMALL_CLOSE     reduce using rule 24 (update_exp -> empty .)


state 62

    (21) conditional_exp -> IDENTIFIER RELATIONAL_OP IDENTIFIER .

    SEMI_COLON      reduce using rule 21 (conditional_exp -> IDENTIFIER RELATIONAL_OP IDENTIFIER .)


state 63

    (20) conditional_exp -> IDENTIFIER RELATIONAL_OP NUM_LITERAL .

    SEMI_COLON      reduce using rule 20 (conditional_exp -> IDENTIFIER RELATIONAL_OP NUM_LITERAL .)


state 64

    (10) switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE .

    FOR             reduce using rule 10 (switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE .)
    SWITCH          reduce using rule 10 (switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE .)
    PRINT           reduce using rule 10 (switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE .)
    FLOW_CLOSE      reduce using rule 10 (switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE .)
    BREAK           reduce using rule 10 (switch_stmt -> SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE .)


state 65

    (11) switch_body -> case_block switch_body .

    FLOW_CLOSE      reduce using rule 11 (switch_body -> case_block switch_body .)


state 66

    (13) case_block -> CASE NUM_LITERAL . COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE

    COLON           shift and go to state 71


state 67

    (14) default_block -> DEFAULT COLON . FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE

    FLOW_OPEN       shift and go to state 72


state 68

    (15) print_stmt -> PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON .

    PRINT           reduce using rule 15 (print_stmt -> PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON .)
    FOR             reduce using rule 15 (print_stmt -> PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON .)
    SWITCH          reduce using rule 15 (print_stmt -> PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON .)
    FLOW_CLOSE      reduce using rule 15 (print_stmt -> PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON .)
    BREAK           reduce using rule 15 (print_stmt -> PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON .)


state 69

    (16) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE . FLOW_OPEN stmt FLOW_CLOSE

    FLOW_OPEN       shift and go to state 73


state 70

    (23) update_exp -> IDENTIFIER UNARY_OP .

    SMALL_CLOSE     reduce using rule 23 (update_exp -> IDENTIFIER UNARY_OP .)


state 71

    (13) case_block -> CASE NUM_LITERAL COLON . FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE

    FLOW_OPEN       shift and go to state 74


state 72

    (14) default_block -> DEFAULT COLON FLOW_OPEN . stmt BREAK SEMI_COLON FLOW_CLOSE
    (4) stmt -> . for_stmt stmt
    (5) stmt -> . switch_stmt stmt
    (6) stmt -> . other_stmt stmt
    (7) stmt -> . empty
    (16) for_stmt -> . FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (10) switch_stmt -> . SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . empty
    (29) empty -> .
    (15) print_stmt -> . PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    FOR             shift and go to state 17
    SWITCH          shift and go to state 18
    BREAK           reduce using rule 29 (empty -> .)
    PRINT           shift and go to state 20

  ! FOR             [ reduce using rule 29 (empty -> .) ]
  ! SWITCH          [ reduce using rule 29 (empty -> .) ]
  ! PRINT           [ reduce using rule 29 (empty -> .) ]

    stmt                           shift and go to state 75
    for_stmt                       shift and go to state 13
    switch_stmt                    shift and go to state 14
    other_stmt                     shift and go to state 15
    empty                          shift and go to state 16
    print_stmt                     shift and go to state 19

state 73

    (16) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN . stmt FLOW_CLOSE
    (4) stmt -> . for_stmt stmt
    (5) stmt -> . switch_stmt stmt
    (6) stmt -> . other_stmt stmt
    (7) stmt -> . empty
    (16) for_stmt -> . FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (10) switch_stmt -> . SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . empty
    (29) empty -> .
    (15) print_stmt -> . PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    FOR             shift and go to state 17
    SWITCH          shift and go to state 18
    FLOW_CLOSE      reduce using rule 29 (empty -> .)
    PRINT           shift and go to state 20

  ! FOR             [ reduce using rule 29 (empty -> .) ]
  ! SWITCH          [ reduce using rule 29 (empty -> .) ]
  ! PRINT           [ reduce using rule 29 (empty -> .) ]

    stmt                           shift and go to state 76
    for_stmt                       shift and go to state 13
    switch_stmt                    shift and go to state 14
    other_stmt                     shift and go to state 15
    empty                          shift and go to state 16
    print_stmt                     shift and go to state 19

state 74

    (13) case_block -> CASE NUM_LITERAL COLON FLOW_OPEN . stmt BREAK SEMI_COLON FLOW_CLOSE
    (4) stmt -> . for_stmt stmt
    (5) stmt -> . switch_stmt stmt
    (6) stmt -> . other_stmt stmt
    (7) stmt -> . empty
    (16) for_stmt -> . FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE
    (10) switch_stmt -> . SWITCH SMALL_OPEN IDENTIFIER SMALL_CLOSE FLOW_OPEN switch_body FLOW_CLOSE
    (8) other_stmt -> . print_stmt other_stmt
    (9) other_stmt -> . empty
    (29) empty -> .
    (15) print_stmt -> . PRINT SMALL_OPEN QUOTE IDENTIFIER QUOTE SMALL_CLOSE SEMI_COLON

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
    FOR             shift and go to state 17
    SWITCH          shift and go to state 18
    BREAK           reduce using rule 29 (empty -> .)
    PRINT           shift and go to state 20

  ! FOR             [ reduce using rule 29 (empty -> .) ]
  ! SWITCH          [ reduce using rule 29 (empty -> .) ]
  ! PRINT           [ reduce using rule 29 (empty -> .) ]

    stmt                           shift and go to state 77
    for_stmt                       shift and go to state 13
    switch_stmt                    shift and go to state 14
    other_stmt                     shift and go to state 15
    empty                          shift and go to state 16
    print_stmt                     shift and go to state 19

state 75

    (14) default_block -> DEFAULT COLON FLOW_OPEN stmt . BREAK SEMI_COLON FLOW_CLOSE

    BREAK           shift and go to state 78


state 76

    (16) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt . FLOW_CLOSE

    FLOW_CLOSE      shift and go to state 79


state 77

    (13) case_block -> CASE NUM_LITERAL COLON FLOW_OPEN stmt . BREAK SEMI_COLON FLOW_CLOSE

    BREAK           shift and go to state 80


state 78

    (14) default_block -> DEFAULT COLON FLOW_OPEN stmt BREAK . SEMI_COLON FLOW_CLOSE

    SEMI_COLON      shift and go to state 81


state 79

    (16) for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .

    FOR             reduce using rule 16 (for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .)
    SWITCH          reduce using rule 16 (for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .)
    PRINT           reduce using rule 16 (for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .)
    FLOW_CLOSE      reduce using rule 16 (for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .)
    BREAK           reduce using rule 16 (for_stmt -> FOR SMALL_OPEN init_exp SEMI_COLON conditional_exp SEMI_COLON update_exp SMALL_CLOSE FLOW_OPEN stmt FLOW_CLOSE .)


state 80

    (13) case_block -> CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK . SEMI_COLON FLOW_CLOSE

    SEMI_COLON      shift and go to state 82


state 81

    (14) default_block -> DEFAULT COLON FLOW_OPEN stmt BREAK SEMI_COLON . FLOW_CLOSE

    FLOW_CLOSE      shift and go to state 83


state 82

    (13) case_block -> CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON . FLOW_CLOSE

    FLOW_CLOSE      shift and go to state 84


state 83

    (14) default_block -> DEFAULT COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE .

    FLOW_CLOSE      reduce using rule 14 (default_block -> DEFAULT COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE .)


state 84

    (13) case_block -> CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE .

    CASE            reduce using rule 13 (case_block -> CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE .)
    DEFAULT         reduce using rule 13 (case_block -> CASE NUM_LITERAL COLON FLOW_OPEN stmt BREAK SEMI_COLON FLOW_CLOSE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for FOR in state 11 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 11 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 11 resolved as shift
WARNING: shift/reduce conflict for FOR in state 13 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 13 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 13 resolved as shift
WARNING: shift/reduce conflict for FOR in state 14 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 14 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 14 resolved as shift
WARNING: shift/reduce conflict for FOR in state 15 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 15 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 15 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 19 resolved as shift
WARNING: shift/reduce conflict for FOR in state 72 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 72 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 72 resolved as shift
WARNING: shift/reduce conflict for FOR in state 73 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 73 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 73 resolved as shift
WARNING: shift/reduce conflict for FOR in state 74 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 74 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 74 resolved as shift
WARNING: reduce/reduce conflict in state 16 resolved using rule (stmt -> empty)
WARNING: rejected rule (other_stmt -> empty) in state 16
